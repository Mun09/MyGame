<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Tetris</title>

	<style>
		body {
			height: 100%;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<canvas id="canvas" width="800" height="2000"></canvas>
	<script>
		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min)) + min;
		}

		const canvas = document.getElementById("canvas");

		const ctx = canvas.getContext("2d");
		ctx.fillStyle = "gray";

		const borderWidth = 5;
		const blockSize = 30;
		const canvasWidth = 10;
		const canvasHeight = 25;

		function initBlockArray(blockArray) {
			for(let x = 0; x < canvasWidth; x++) {
				blockArray[x] = new Array(canvasHeight);
			}

			for(let x = 0; x < canvasWidth; x++) {
				for(let y = 0; y < canvasHeight; y++) {
					blockArray[x][y] = false;
				}
			}
		}

		function drawBlocks() {
			for(let x = 0; x < canvasWidth; x++) {
				for(let y = 0; y < canvasHeight; y++) {
					if(stackedBlock[x][y]) {
						ctx.fillStyle = "black";
					} else {
						ctx.fillStyle = "gray";
					}

					if(controlBlock[x][y]) {
						ctx.fillStyle = "blue";
					}

					ctx.fillRect(
						borderWidth * x + blockSize * x,
						borderWidth * y + blockSize * y,
						blockSize, 
						blockSize
					);
				}
			}
		}

		function CopyAndDown(blockArray) {
			let tmpBlockArray = new Array(canvasWidth);
			initBlockArray(tmpBlockArray);

			for(let x = 0; x < canvasWidth; x++) {
				for(let y = 0; y < canvasHeight; y++) {
					if(controlBlock[x][y] == true) {
						tmpBlockArray[x][y+1] = true;
					}
				}
			}
			return tmpBlockArray;
		}

		function isCollided(thisArray, thatArray) {
			for(var x = 0; x < canvasWidth; x++) {
				if(thisArray[x][canvasHeight-1] == true) return true;
			}

			for(let x = 0; x < canvasWidth; x++) {
				for(let y = 0; y < canvasHeight; y++) {
					if(thisArray[x][y] == true && thatArray[x][y+1] == true) return true;
				}
			}
			return false;
		}

		function flowGravity() {
			let collisionCheckArray = CopyAndDown(controlBlock);
			if(isCollided(collisionCheckArray, stackedBlock)) {

			} else {
				controlBlock = collisionCheckArray;
			}
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawBlocks();
		}

		function TimeGo() {
			var timeId = setInterval(flowGravity, 300);
		}

		let stackedBlock = new Array(canvasWidth);
		let controlBlock = new Array(canvasWidth);

		initBlockArray(stackedBlock);
		initBlockArray(controlBlock);

		// function flowGravity() {
		// 	let collisionCheckTmpArray = copyBlockArray(controlBlock);
		// }

		for(x = 0; x < canvasWidth; x++) {
			for(y = 0; y < canvasHeight; y++) {
				ctx.fillRect(
					borderWidth * x + blockSize * x,
					borderWidth * y + blockSize * y,
					blockSize, 
					blockSize
				);
			}
		}

		const ColorArray = ["red", "blue", "green", "yellow"];
		const BlockArray = [
			[1, 1, 1, 1, 0, 0, 0, 0],
			[1, 0, 0, 0, 1, 1, 1, 0],
			[1, 1, 0, 0, 1, 1, 0, 0],
			[0, 1, 1, 0, 1, 1, 0, 0]
		];

		controlBlock[5][0] = true;

		TimeGo();


		
	</script>
</body>
</html>